predicate sorted(int[] arr, int low, int high) := 
  (forall sorted_a,sorted_b. ((low <= sorted_a && sorted_a <= sorted_b && sorted_b <= high) -> arr[sorted_a]<=arr[sorted_b]));

predicate partitioned(int[] arr, int low1, int high1, int low2, int high2) :=
  (forall partitioned_a, partitioned_b. ((low1 <= partitioned_a && partitioned_a <= high1 && low2 <= partitioned_b && partitioned_b <= high2)-> arr[partitioned_a]<=arr[partitioned_b]));

@pre  true
@post sorted(rv,0,|rv|-1)
# (|arr_0| + 1, |arr_0| + 1)
int[] BubbleSort(int[] arr_0) {
	int[] arr := arr_0;
	for
	@ 	sorted(arr, i, |arr| - 1) &&
	   	-1 <= i && i < |arr| &&
    partitioned(arr, 0, i, i+1, |arr|-1)
		# (i + 1, i + 1)
	(int i := |arr| - 1; i > 0; i := i - 1)
	{
		for
		@ 	partitioned(arr, 0, i, i + 1, |arr| - 1) &&	
			1 <= i && i < |arr| && 0 <= j && j <= i &&
	       sorted(arr, i, |arr| - 1) && 
 			partitioned(arr, 0, j - 1, j, j)
		# (i + 1, i - j)
		(int j := 0; j < i; j := j + 1)
		{
			if (arr[j] > arr[j + 1]) {
				int temp := arr[j];
				arr[j] := arr[j + 1];
				arr[j + 1] := temp;
			}
		}
	}
	return arr;
}
